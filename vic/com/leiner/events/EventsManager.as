package com.leiner.events{	import flash.events.EventDispatcher;	import flash.events.MouseEvent;		public final class EventsManager 	{		private static var listeners:Vector.<Object> = new Vector.<Object>();		private static var instance:EventsManager = new EventsManager();		public function EventsManager () 		{			if( instance ) throw new Error( "EventsManager and can only be accessed through EventsManager.getInstance()" );		}				public function registerButton ( ctrl:*, groups:Array, listenersObj:Object ):void		{			if (groups==null) groups = ['main'];			try { ctrl.buttonMode = true } catch (e) { }			try { ctrl.useHandCursor = true } catch (e) { }			try { ctrl.mouseChildren = false; } catch (e) { }						if (listenersObj.hasOwnProperty('click')) add ( groups, ctrl, MouseEvent.CLICK, listenersObj.click );			if (listenersObj.hasOwnProperty('double')) 			{				try { ctrl.doubleClickEnabled = true}catch (e) { }				add ( groups, ctrl, MouseEvent.DOUBLE_CLICK, listenersObj.double );			}						if (listenersObj.hasOwnProperty('rollOut')) add ( groups, ctrl, MouseEvent.ROLL_OUT, listenersObj.rollOut);			if (listenersObj.hasOwnProperty('rollOver')) add ( groups, ctrl, MouseEvent.ROLL_OVER, listenersObj.rollOver);						var mtypes = ['over', 'out', 'down', 'up', 'move', 'wheel'];			for each(var item in mtypes)			{				if (listenersObj.hasOwnProperty(item)) 					add ( groups, ctrl, 'mouse' + upperCase(item), listenersObj[item]);			}		}						private function upperCase ( str:String ) : String 		{			var firstChar:String = str.substr(0, 1); 			var restOfString:String = str.substr(1, str.length); 			return firstChar.toUpperCase() + restOfString.toLowerCase(); 		}				public function add ( groups:Array , dispatcher:EventDispatcher, type:String='', method:Function=null, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = true ):void 		{			if (groups == null) groups = ['main'];			var node = new DispatcherVO ( groups , dispatcher, type, method, useCapture, priority, useWeakReference );			listeners.push( node);		}				public function remove ( groups:Array, dispatcher:EventDispatcher, type:String, method:Function, useCapture:Boolean = false ):void 		{			if (groups == null) groups = ['main'];			dispatcher.removeEventListener(type, method, useCapture);						for (var i:int = 0; i < listeners.length; i++ ) 			{				var node=listeners[i] as DispatcherVO;				if (node.dispatcher == dispatcher && node.type == type && node.method == method && checkGroups(node.groups,groups))					listeners.splice(i, 1);			}		}				private function checkGroups ( arr1:Array, arr2:Array ):Boolean		{			if (arr1.length != arr2.length) return false;			var count:int = 0;			for (var i:int = 0; i < arr1.length; i++)			{				if (arr1[i] == arr2[i]) count++;			}			return ( count == arr1.length ) ? true : false;		}				public function resumeGroup ( value:String ):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{				var node = listeners[i] as DispatcherVO;				if ( node.groups.indexOf(value) > -1 ) 				{					node.start();				}			}		}				public function suspendGroup ( value:String ):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{								var node = listeners[i] as DispatcherVO;				if ( node.groups.indexOf(value) > -1 ) 				{					node.stop();				}			}		}				public function removeGroup(value:String):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{				var node = listeners[i] as DispatcherVO;				if ( node.groups.indexOf(value) > -1 ) 				{					node.stop();					listeners.splice(i, 1)	;				}			}		}				public function resume ( value:EventDispatcher, type:String, method:Function ):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{				var node = listeners[i] as DispatcherVO;				if (node.dispatcher == value && node.type == type && node.method == method)				{					node.start();				}			}		}				public function suspend(value:EventDispatcher,type:String,method:Function):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{				var node = listeners[i] as DispatcherVO;				if (node.dispatcher == value && node.type == type && node.method == method)				{					node.stop();				}			}		}							public function resumeDispatcher ( value:EventDispatcher ):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{				var node = listeners[i] as DispatcherVO;				if (node.dispatcher == value)				{					node.start();				}			}		}				public function suspendDispatcher( value:EventDispatcher ):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{				var node = listeners[i] as DispatcherVO;				if (node.dispatcher == value)				{					node.stop();				}			}		}							public function removeDispatcher( value:EventDispatcher ):void		{			for (var i:int = listeners.length - 1; i = 0; i--)			{				var node = listeners[i] as DispatcherVO;				if (node.dispatcher == value) 				{					node.stop();					listeners.splice(i, 1);						}			}		}					public function removeAll():void		{			while (listeners.length) 			{				var node = listeners[0] as DispatcherVO;				node.stop()				listeners.shift();			}		}						public static function getInstance():EventsManager 		{			return instance;		}	}}import flash.events.EventDispatcher;class DispatcherVO extends Object{	public var groups:Array = [];	public var dispatcher:EventDispatcher;	public var type:String = '';	public var method:Function = null;	public var useCapture:Boolean = false	public var priority:int = 0;	public var useWeakReference:Boolean = true;		public function DispatcherVO ( groups:Array, dispatcher:EventDispatcher, type:String, method:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = true):void 	{		this.groups = groups;		this.dispatcher = dispatcher;		this.type = type;		this.method = method;		this.useCapture = useCapture;		this.priority = priority;		this.useWeakReference = useWeakReference;		start();	}		public function start():void 	{		dispatcher.addEventListener(type, method, useCapture, priority, useWeakReference);	}		public function stop():void 	{		dispatcher.removeEventListener(type, method, useCapture);	}	}